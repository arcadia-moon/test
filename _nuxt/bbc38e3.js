(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{509:function(n,e,t){"use strict";t(11),t(14),t(20),t(21);var r=t(2),o=(t(5),t(31),t(13),t(32),t(62),t(492),t(54),t(493),t(494),t(495),t(496),t(497),t(498),t(499),t(500),t(501),t(502),t(503),t(504),t(505),t(63),t(47),t(12),t(81),t(487),t(1)),c=t(111),l=t(0);function d(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function m(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?d(Object(t),!0).forEach((function(e){Object(r.a)(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):d(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}var h=["sm","md","lg","xl"],f=h.reduce((function(n,e){return n[e]={type:[Boolean,String,Number],default:!1},n}),{}),_=h.reduce((function(n,e){return n["offset"+Object(l.u)(e)]={type:[String,Number],default:null},n}),{}),y=h.reduce((function(n,e){return n["order"+Object(l.u)(e)]={type:[String,Number],default:null},n}),{}),w={col:Object.keys(f),offset:Object.keys(_),order:Object.keys(y)};function v(n,e,t){var r=n;if(null!=t&&!1!==t){if(e){var o=e.replace(n,"");r+="-".concat(o)}return"col"!==n||""!==t&&!0!==t?(r+="-".concat(t)).toLowerCase():r.toLowerCase()}}var k=new Map;e.a=o.a.extend({name:"v-col",functional:!0,props:m(m(m(m({cols:{type:[Boolean,String,Number],default:!1}},f),{},{offset:{type:[String,Number],default:null}},_),{},{order:{type:[String,Number],default:null}},y),{},{alignSelf:{type:String,default:null,validator:function(n){return["auto","start","end","center","baseline","stretch"].includes(n)}},tag:{type:String,default:"div"}}),render:function(n,e){var t=e.props,data=e.data,o=e.children,l=(e.parent,"");for(var d in t)l+=String(t[d]);var m=k.get(l);if(!m){var h,f;for(f in m=[],w)w[f].forEach((function(n){var e=t[n],r=v(f,n,e);r&&m.push(r)}));var _=m.some((function(n){return n.startsWith("col-")}));m.push((h={col:!_||!t.cols},Object(r.a)(h,"col-".concat(t.cols),t.cols),Object(r.a)(h,"offset-".concat(t.offset),t.offset),Object(r.a)(h,"order-".concat(t.order),t.order),Object(r.a)(h,"align-self-".concat(t.alignSelf),t.alignSelf),h)),k.set(l,m)}return n(t.tag,Object(c.a)(data,{class:m}),o)}})},524:function(n,e,t){var content=t(583);content.__esModule&&(content=content.default),"string"==typeof content&&(content=[[n.i,content,""]]),content.locals&&(n.exports=content.locals);(0,t(23).default)("9cf85bb0",content,!0,{sourceMap:!1})},560:function(n,e,t){var map={"./EX0005.md":561,"./EX0006.md":562,"./EX0007.md":563,"./EX0008.md":564,"./EX0010.md":565,"./EX0011.md":566,"./EX0012.md":567,"./EX0014.md":568,"./EX0015.md":569,"./EX0017.md":570,"./EX0018.md":571,"./EX0019.md":572,"./EX0021.md":573,"./EX0022.md":574,"./EX0023.md":575,"./EX0024.md":576,"./EX0027.md":577,"./EX0029.md":578,"./EX0030.md":579,"./EX0036.md":580,"./EX0037.md":581};function r(n){var e=o(n);return t(e)}function o(n){if(!t.o(map,n)){var e=new Error("Cannot find module '"+n+"'");throw e.code="MODULE_NOT_FOUND",e}return map[n]}r.keys=function(){return Object.keys(map)},r.resolve=o,n.exports=r,r.id=560},561:function(n,e,t){"use strict";t.r(e),e.default='<section><h3>proxy.sol</h3>\n<pre><code class="language-solidity">pragma solidity ^0.4.24;\n\ncontract Proxy {\n\n  address owner;\n\n  constructor() public {\n    owner = msg.sender;  \n  }\n\n  function forward(address callee, bytes _data) public {\n    require(callee.delegatecall(_data));\n  }\n\n}\n\n</code></pre>\n<h3>proxy_fixed.sol</h3>\n<pre><code class="language-solidity">pragma solidity ^0.4.24;\n\ncontract Proxy {\n\n  address callee;\n  address owner;\n\n  modifier onlyOwner {\n    require(msg.sender == owner);\n    _;\n  }\n\n  constructor() public {\n  \tcallee = address(0x0);\n    owner = msg.sender;\n  }\n\n  function setCallee(address newCallee) public onlyOwner {\n  \tcallee = newCallee;\n  }\n\n  function forward(bytes _data) public {\n    require(callee.delegatecall(_data));\n  }\n\n}\n\n</code></pre>\n<h3>proxy_pattern_false_positive.sol</h3>\n<pre><code class="language-solidity">pragma solidity ^0.4.24;\n\ncontract proxy{\n  address owner;\n\n  function proxyCall(address _to, bytes _data) external {\n    require( !_to.delegatecall(_data));\n  }\n  function withdraw() external{\n    require(msg.sender == owner);\n    msg.sender.transfer(address(this).balance);\n  }\n} \n\n/*\nYou can\'t use proxyCall to change the owner address as either: \n\n1) the delegatecall reverts and thus does not change owner\n2) the delegatecall does not revert and therefore will cause the proxyCall to revert and preventing owner from changing\n\nThis false positive may seem like a really edge case, however since you can revert data back to proxy this patern is useful for proxy architectures\n*/\n</code></pre>\n</section>\n'},562:function(n,e,t){"use strict";t.r(e),e.default='<section><h3>modifier_reentrancy.sol</h3>\n<pre><code class="language-solidity">pragma solidity ^0.5.0;\n\ncontract ModifierEntrancy {\n\n  mapping (address =&gt; uint) public tokenBalance;\n  string constant name = &quot;Nu Token&quot;;\n  Bank bank;\n  \n  constructor() public{\n      bank = new Bank();\n  }\n\n  //If a contract has a zero balance and supports the token give them some token\n  function airDrop() hasNoBalance supportsToken  public{\n    tokenBalance[msg.sender] += 20;\n  }\n  \n  //Checks that the contract responds the way we want\n  modifier supportsToken() {\n    require(keccak256(abi.encodePacked(&quot;Nu Token&quot;)) == bank.supportsToken());\n    _;\n  }\n  \n  //Checks that the caller has a zero balance\n  modifier hasNoBalance {\n      require(tokenBalance[msg.sender] == 0);\n      _;\n  }\n}\n\ncontract Bank{\n\n    function supportsToken() external returns(bytes32) {\n        return keccak256(abi.encodePacked(&quot;Nu Token&quot;));\n    }\n\n}\n\n</code></pre>\n<h3>modifier_reentrancy_fixed.sol</h3>\n<pre><code class="language-solidity">pragma solidity ^0.5.0;\n\ncontract ModifierEntrancy {\n  mapping (address =&gt; uint) public tokenBalance;\n  string constant name = &quot;Nu Token&quot;;\n  Bank bank;\n  constructor() public{\n      bank = new Bank();\n  }\n\n  //If a contract has a zero balance and supports the token give them some token\n  function airDrop() supportsToken hasNoBalance  public{ // In the fixed version supportsToken comes before hasNoBalance\n    tokenBalance[msg.sender] += 20;\n  }\n\n  //Checks that the contract responds the way we want\n  modifier supportsToken() {\n    require(keccak256(abi.encodePacked(&quot;Nu Token&quot;)) == bank.supportsToken());\n    _;\n  }\n  //Checks that the caller has a zero balance\n  modifier hasNoBalance {\n      require(tokenBalance[msg.sender] == 0);\n      _;\n  }\n}\n\ncontract Bank{\n\n    function supportsToken() external returns(bytes32){\n        return(keccak256(abi.encodePacked(&quot;Nu Token&quot;)));\n    }\n}\n\n</code></pre>\n<h3>simple_dao.sol</h3>\n<pre><code class="language-solidity">/*\n * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#simpledao\n * @author: Atzei N., Bartoletti M., Cimoli T\n * Modified by Josselin Feist\n */\npragma solidity 0.4.24;\n\ncontract SimpleDAO {\n  mapping (address =&gt; uint) public credit;\n    \n  function donate(address to) payable public{\n    credit[to] += msg.value;\n  }\n    \n  function withdraw(uint amount) public{\n    if (credit[msg.sender]&gt;= amount) {\n      require(msg.sender.call.value(amount)());\n      credit[msg.sender]-=amount;\n    }\n  }  \n\n  function queryCredit(address to) view public returns(uint){\n    return credit[to];\n  }\n}\n\n</code></pre>\n<h3>simple_dao_fixed.sol</h3>\n<pre><code class="language-solidity">/*\n * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#simpledao\n * @author: Atzei N., Bartoletti M., Cimoli T\n * Modified by Bernhard Mueller, Josselin Feist\n */\npragma solidity 0.4.24;\n\ncontract SimpleDAO {\n  mapping (address =&gt; uint) public credit;\n    \n  function donate(address to) payable public{\n    credit[to] += msg.value;\n  }\n    \n  function withdraw(uint amount) public {\n    if (credit[msg.sender]&gt;= amount) {\n      credit[msg.sender]-=amount;\n      require(msg.sender.call.value(amount)());\n    }\n  }  \n\n  function queryCredit(address to) view public returns (uint){\n    return credit[to];\n  }\n}\n\n</code></pre>\n</section>\n'},563:function(n,e,t){"use strict";t.r(e),e.default='<section><h3>send_loop.sol</h3>\n<pre><code class="language-solidity">/*\n * @source: https://consensys.github.io/smart-contract-best-practices/known_attacks/#dos-with-unexpected-revert\n * @author: ConsenSys Diligence\n * Modified by Bernhard Mueller\n */\n\npragma solidity 0.4.24;\n\ncontract Refunder {\n\t\naddress[] private refundAddresses;\nmapping (address =&gt; uint) public refunds;\n\n\tconstructor() {\n\t\trefundAddresses.push(0x79B483371E87d664cd39491b5F06250165e4b184);\n\t\trefundAddresses.push(0x79B483371E87d664cd39491b5F06250165e4b185);\n\t}\n\n\t// bad\n\tfunction refundAll() public {\n\t    for(uint x; x &lt; refundAddresses.length; x++) { // arbitrary length iteration based on how many addresses participated\n\t        require(refundAddresses[x].send(refunds[refundAddresses[x]])); // doubly bad, now a single failure on send will hold up all funds\n\t    }\n\t}\n\n}\n\n</code></pre>\n</section>\n'},564:function(n,e,t){"use strict";t.r(e),e.default="<section><h3>relayer.sol</h3>\n<pre><code class=\"language-solidity\">/*\n * @source: https://consensys.github.io/smart-contract-best-practices/known_attacks/#insufficient-gas-griefing\n * @author: ConsenSys Diligence\n * Modified by Kaden Zipfel\n */\n\npragma solidity ^0.5.0;\n\ncontract Relayer {\n    uint transactionId;\n\n    struct Tx {\n        bytes data;\n        bool executed;\n    }\n\n    mapping (uint =&gt; Tx) transactions;\n\n    function relay(Target target, bytes memory _data) public returns(bool) {\n        // replay protection; do not call the same transaction twice\n        require(transactions[transactionId].executed == false, 'same transaction twice');\n        transactions[transactionId].data = _data;\n        transactions[transactionId].executed = true;\n        transactionId += 1;\n\n        (bool success, ) = address(target).call(abi.encodeWithSignature(&quot;execute(bytes)&quot;, _data));\n        return success;\n    }\n}\n\n// Contract called by Relayer\ncontract Target {\n    function execute(bytes memory _data) public {\n        // Execute contract code\n    }\n}\n\n</code></pre>\n<h3>relayer_fixed.sol</h3>\n<pre><code class=\"language-solidity\">/*\n * @source: https://consensys.github.io/smart-contract-best-practices/known_attacks/#insufficient-gas-griefing\n * @author: ConsenSys Diligence\n * Modified by Kaden Zipfel\n */\n\npragma solidity ^0.5.0;\n\ncontract Relayer {\n    uint transactionId;\n\n    struct Tx {\n        bytes data;\n        bool executed;\n    }\n\n    mapping (uint =&gt; Tx) transactions;\n\n    function relay(Target target, bytes memory _data, uint _gasLimit) public {\n        // replay protection; do not call the same transaction twice\n        require(transactions[transactionId].executed == false, 'same transaction twice');\n        transactions[transactionId].data = _data;\n        transactions[transactionId].executed = true;\n        transactionId += 1;\n\n        address(target).call(abi.encodeWithSignature(&quot;execute(bytes)&quot;, _data, _gasLimit));\n    }\n}\n\n// Contract called by Relayer\ncontract Target {\n    function execute(bytes memory _data, uint _gasLimit) public {\n        require(gasleft() &gt;= _gasLimit, 'not enough gas');\n        // Execute contract code\n    }\n}\n\n</code></pre>\n</section>\n"},565:function(n,e,t){"use strict";t.r(e),e.default='<section><h3>tokensalechallenge.sol</h3>\n<pre><code class="language-solidity">/*\n * @source: https://capturetheether.com/challenges/math/token-sale/\n * @author: Steve Marx\n */\n\npragma solidity ^0.4.21;\n\ncontract TokenSaleChallenge {\n    mapping(address =&gt; uint256) public balanceOf;\n    uint256 constant PRICE_PER_TOKEN = 1 ether;\n\n    function TokenSaleChallenge(address _player) public payable {\n        require(msg.value == 1 ether);\n    }\n\n    function isComplete() public view returns (bool) {\n        return address(this).balance &lt; 1 ether;\n    }\n\n    function buy(uint256 numTokens) public payable {\n        require(msg.value == numTokens * PRICE_PER_TOKEN);\n\n        balanceOf[msg.sender] += numTokens;\n    }\n\n    function sell(uint256 numTokens) public {\n        require(balanceOf[msg.sender] &gt;= numTokens);\n\n        balanceOf[msg.sender] -= numTokens;\n        msg.sender.transfer(numTokens * PRICE_PER_TOKEN);\n    }\n}\n</code></pre>\n<h3>integer_overflow_mapping_sym_1.sol</h3>\n<pre><code class="language-solidity">//Single transaction overflow\n\npragma solidity ^0.4.11;\n\ncontract IntegerOverflowMappingSym1 {\n    mapping(uint256 =&gt; uint256) map;\n\n    function init(uint256 k, uint256 v) public {\n        map[k] -= v;\n    }\n}\n\n</code></pre>\n<h3>integer_overflow_mapping_sym_1_fixed.sol</h3>\n<pre><code class="language-solidity">//Single transaction overflow\n//Safe version\n\npragma solidity ^0.4.16;\n\ncontract IntegerOverflowMappingSym1 {\n    mapping(uint256 =&gt; uint256) map;\n\n    function init(uint256 k, uint256 v) public {\n        map[k] = sub(map[k], v);\n    }\n\n    //from SafeMath\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b &lt;= a);//SafeMath uses assert here\n        return a - b;\n    }\n}\n\n</code></pre>\n<h3>integer_overflow_minimal.sol</h3>\n<pre><code class="language-solidity">//Single transaction overflow\n//Post-transaction effect: overflow escapes to publicly-readable storage\n\npragma solidity ^0.4.19;\n\ncontract IntegerOverflowMinimal {\n    uint public count = 1;\n\n    function run(uint256 input) public {\n        count -= input;\n    }\n}\n\n</code></pre>\n<h3>integer_overflow_minimal_fixed.sol</h3>\n<pre><code class="language-solidity">//Single transaction overflow\n//Post-transaction effect: overflow escapes to publicly-readable storage\n//Safe version\n\npragma solidity ^0.4.19;\n\ncontract IntegerOverflowMinimal {\n    uint public count = 1;\n\n    function run(uint256 input) public {\n        count = sub(count,input);\n    }\n\n    //from SafeMath\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b &lt;= a);//SafeMath uses assert here\n        return a - b;\n    }\n}\n\n</code></pre>\n<h3>integer_overflow_mul.sol</h3>\n<pre><code class="language-solidity">//Single transaction overflow\n//Post-transaction effect: overflow escapes to publicly-readable storage\n\npragma solidity ^0.4.19;\n\ncontract IntegerOverflowMul {\n    uint public count = 2;\n\n    function run(uint256 input) public {\n        count *= input;\n    }\n}\n\n</code></pre>\n<h3>integer_overflow_mul_fixed.sol</h3>\n<pre><code class="language-solidity">//Single transaction overflow\n//Post-transaction effect: overflow escapes to publicly-readable storage\n//Safe version\n\npragma solidity ^0.4.19;\n\ncontract IntegerOverflowMul {\n    uint public count = 2;\n\n    function run(uint256 input) public {\n        count = mul(count, input);\n    }\n\n    //from SafeMath\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n      // Gas optimization: this is cheaper than requiring \'a\' not being zero, but the\n      // benefit is lost if \'b\' is also tested.\n      // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n      if (a == 0) {\n        return 0;\n      }\n\n      uint256 c = a * b;\n      require(c / a == b);\n\n      return c;\n    }\n}\n\n</code></pre>\n<h3>integer_overflow_multitx_multifunc_feasible.sol</h3>\n<pre><code class="language-solidity">/*\n * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite\n * @author: Suhabe Bugrara\n */\n\n//Multi-transactional, multi-function\n//Arithmetic instruction reachable\n\npragma solidity ^0.4.23;\n\ncontract IntegerOverflowMultiTxMultiFuncFeasible {\n    uint256 private initialized = 0;\n    uint256 public count = 1;\n\n    function init() public {\n        initialized = 1;\n    }\n\n    function run(uint256 input) {\n        if (initialized == 0) {\n            return;\n        }\n\n        count -= input;\n    }\n}\n\n</code></pre>\n<h3>integer_overflow_multitx_multifunc_feasible_fixed.sol</h3>\n<pre><code class="language-solidity">/*\n * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite\n * @author: Suhabe Bugrara\n */\n\n//Multi-transactional, multi-function\n//Arithmetic instruction reachable (Safe)\n\npragma solidity ^0.4.23;\n\ncontract IntegerOverflowMultiTxMultiFuncFeasible {\n    uint256 private initialized = 0;\n    uint256 public count = 1;\n\n    function init() public {\n        initialized = 1;\n    }\n\n    function run(uint256 input) {\n        if (initialized == 0) {\n            return;\n        }\n\n        count = sub(count, input);\n    }\n\n    //from SafeMath\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b &lt;= a);//SafeMath uses assert here\n        return a - b;\n    }\n}\n\n</code></pre>\n<h3>integer_overflow_multitx_onefunc_feasible.sol</h3>\n<pre><code class="language-solidity">/*\n * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite\n * @author: Suhabe Bugrara\n */\n\n//Multi-transactional, single function\n//Arithmetic instruction reachable\n\npragma solidity ^0.4.23;\n\ncontract IntegerOverflowMultiTxOneFuncFeasible {\n    uint256 private initialized = 0;\n    uint256 public count = 1;\n\n    function run(uint256 input) public {\n        if (initialized == 0) {\n            initialized = 1;\n            return;\n        }\n\n        count -= input;\n    }\n}\n\n</code></pre>\n<h3>integer_overflow_multitx_onefunc_feasible_fixed.sol</h3>\n<pre><code class="language-solidity">/*\n * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite\n * @author: Suhabe Bugrara\n */\n\n//Multi-transactional, single function\n//Arithmetic instruction reachable (Safe)\n\npragma solidity ^0.4.23;\n\ncontract IntegerOverflowMultiTxOneFuncFeasible {\n\n    uint256 private initialized = 0;\n    uint256 public count = 1;\n\n    function run(uint256 input) public {\n        if (initialized == 0) {\n            initialized = 1;\n            return;\n        }\n\n        count = sub(count, input);\n    }\n\n    //from SafeMath\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b &lt;= a);//SafeMath uses assert here\n        return a - b;\n    }\n}\n\n</code></pre>\n<h3>integer_overflow_multitx_onefunc_infeasible.sol</h3>\n<pre><code class="language-solidity">/*\n * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite\n * @author: Suhabe Bugrara\n */\n\n//Multi-transactional, single function\n//Overflow infeasible because arithmetic instruction not reachable\n\npragma solidity ^0.4.23;\n\ncontract IntegerOverflowMultiTxOneFuncInfeasible {\n    uint256 private initialized = 0;\n    uint256 public count = 1;\n\n    function run(uint256 input) public {\n        if (initialized == 0) {\n            return;\n        }\n\n        count -= input;\n    }\n}\n\n</code></pre>\n<h3>overflow_simple_add.sol</h3>\n<pre><code class="language-solidity">pragma solidity 0.4.24;\n\ncontract Overflow_Add {\n    uint public balance = 1;\n\n    function add(uint256 deposit) public {\n        balance += deposit;\n    }\n}\n\n</code></pre>\n<h3>overflow_simple_add_fixed.sol</h3>\n<pre><code class="language-solidity">pragma solidity ^0.4.24;\n\ncontract Overflow_Add {\n    uint public balance = 1;\n\n    function add(uint256 deposit) public {\n        balance = add(balance, deposit);\n    }\n\n    //from SafeMath\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n      uint256 c = a + b;\n      require(c &gt;= a);\n\n      return c;\n    }\n}\n\n</code></pre>\n<h3>BECToken.sol</h3>\n<pre><code class="language-solidity">pragma solidity ^0.4.16;\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n    uint256 c = a * b;\n    require(a == 0 || c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n    // require(b &gt; 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // require(a == b * c + a % b); // There is no case in which this doesn\'t hold\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n    require(b &lt;= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n    uint256 c = a + b;\n    require(c &gt;= a);\n    return c;\n  }\n}\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  uint256 public totalSupply;\n  function balanceOf(address who) public constant returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address =&gt; uint256) balances;\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value &gt; 0 &amp;&amp; _value &lt;= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public constant returns (uint256 balance) {\n    return balances[_owner];\n  }\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public constant returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address =&gt; mapping (address =&gt; uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value &gt; 0 &amp;&amp; _value &lt;= balances[_from]);\n    require(_value &lt;= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender\'s allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n    return allowed[_owner][_spender];\n  }\n}\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of &quot;user permissions&quot;.\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() {\n    owner = msg.sender;\n  }\n\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) onlyOwner public {\n    require(newOwner != address(0));\n    OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    Unpause();\n  }\n}\n\n/**\n * @title Pausable token\n *\n * @dev StandardToken modified with pausable transfers.\n **/\n\ncontract PausableToken is StandardToken, Pausable {\n\n  function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\n    return super.transfer(_to, _value);\n  }\n\n  function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\n    return super.transferFrom(_from, _to, _value);\n  }\n\n  function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\n    return super.approve(_spender, _value);\n  }\n  \n  function batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (bool) {\n    uint cnt = _receivers.length;\n    uint256 amount = uint256(cnt) * _value;\n    require(cnt &gt; 0 &amp;&amp; cnt &lt;= 20);\n    require(_value &gt; 0 &amp;&amp; balances[msg.sender] &gt;= amount);\n\n    balances[msg.sender] = balances[msg.sender].sub(amount);\n    for (uint i = 0; i &lt; cnt; i++) {\n        balances[_receivers[i]] = balances[_receivers[i]].add(_value);\n        Transfer(msg.sender, _receivers[i], _value);\n    }\n    return true;\n  }\n}\n\n/**\n * @title Bec Token\n *\n * @dev Implementation of Bec Token based on the basic standard token.\n */\ncontract BecToken is PausableToken {\n    /**\n    * Public variables of the token\n    * The following variables are OPTIONAL vanities. One does not have to include them.\n    * They allow one to customise the token contract &amp; in no way influences the core functionality.\n    * Some wallets/interfaces might not even bother to look at this information.\n    */\n    string public name = &quot;BeautyChain&quot;;\n    string public symbol = &quot;BEC&quot;;\n    string public version = \'1.0.0\';\n    uint8 public decimals = 18;\n\n    /**\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n     */\n    function BecToken() {\n      totalSupply = 7000000000 * (10**(uint256(decimals)));\n      balances[msg.sender] = totalSupply;    // Give the creator all initial tokens\n    }\n\n    function () {\n        //if ether is sent to this address, send it back.\n        revert();\n    }\n}\n</code></pre>\n</section>\n'},566:function(n,e,t){"use strict";t.r(e),e.default='<section><h3>version_0_4_13.sol</h3>\n<pre><code class="language-solidity">pragma solidity 0.4.13;\n\ncontract OutdatedCompilerVersion {\n    uint public x = 1;\n}\n\n</code></pre>\n</section>\n'},567:function(n,e,t){"use strict";t.r(e),e.default='<section><h3>incorrect_constructor_name1.sol</h3>\n<pre><code class="language-solidity">/*\n * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/wrong_constructor_name/incorrect_constructor.sol\n * @author: Ben Perez\n * Modified by Gerhard Wagner\n */\n\n\npragma solidity 0.4.24;\n\ncontract Missing{\n    address private owner;\n\n    modifier onlyowner {\n        require(msg.sender==owner);\n        _;\n    }\n    \n    function missing()\n        public \n    {\n        owner = msg.sender;\n    }\n\n    function () payable {} \n\n    function withdraw() \n        public \n        onlyowner\n    {\n       owner.transfer(this.balance);\n    }\n}\n\n</code></pre>\n<h3>incorrect_constructor_name1_fixed.sol</h3>\n<pre><code class="language-solidity">/*\n * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/wrong_constructor_name/incorrect_constructor.sol\n * @author: Ben Perez\n * Modified by Gerhard Wagner\n */\n\n\npragma solidity ^0.4.24;\n\ncontract Missing{\n    address private owner;\n\n    modifier onlyowner {\n        require(msg.sender==owner);\n        _;\n    }\n\n    constructor()\n        public\n    {\n        owner = msg.sender;\n    }\n\n    function () payable {}\n\n    function withdraw()\n        public\n        onlyowner\n    {\n       owner.transfer(this.balance);\n    }\n}\n\n</code></pre>\n<h3>incorrect_constructor_name2.sol</h3>\n<pre><code class="language-solidity">/*\n * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/wrong_constructor_name/incorrect_constructor.sol\n * @author: Ben Perez\n * Modified by Gerhard Wagner\n */\n\npragma solidity 0.4.24;\n\ncontract Missing{\n    address private owner;\n\n    modifier onlyowner {\n        require(msg.sender==owner);\n        _;\n    }\n\n    function Constructor()\n        public \n    {\n        owner = msg.sender;\n    }\n\n    function () payable {} \n\n    function withdraw() \n        public \n        onlyowner\n    {\n       owner.transfer(this.balance);\n    }\n\n}\n\n</code></pre>\n<h3>incorrect_constructor_name2_fixed.sol</h3>\n<pre><code class="language-solidity">/*\n * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/wrong_constructor_name/incorrect_constructor.sol\n * @author: Ben Perez\n * Modified by Gerhard Wagner\n */\n\npragma solidity ^0.4.24;\n\ncontract Missing{\n    address private owner;\n\n    modifier onlyowner {\n        require(msg.sender==owner);\n        _;\n    }\n\n    constructor()\n        public\n    {\n        owner = msg.sender;\n    }\n\n    function () payable {}\n\n    function withdraw()\n        public\n        onlyowner\n    {\n       owner.transfer(this.balance);\n    }\n\n}\n\n</code></pre>\n</section>\n'},568:function(n,e,t){"use strict";t.r(e),e.default='<section><h3>storage.sol</h3>\n<pre><code class="language-solidity">pragma solidity 0.4.24;\n\ncontract TestStorage {\n\n    uint storeduint1 = 15;\n    uint constant constuint = 16;\n    uint32 investmentsDeadlineTimeStamp = uint32(now); \n\n    bytes16 string1 = &quot;test1&quot;; \n    bytes32 private string2 = &quot;test1236&quot;; \n    string public string3 = &quot;lets string something&quot;; \n\n    mapping (address =&gt; uint) public uints1; \n    mapping (address =&gt; DeviceData) structs1; \n\n    uint[] uintarray; \n    DeviceData[] deviceDataArray; \n\n    struct DeviceData {\n        string deviceBrand;\n        string deviceYear;\n        string batteryWearLevel;\n    }\n\n    function testStorage() public  {\n        address address1 = 0xbccc714d56bc0da0fd33d96d2a87b680dd6d0df6;\n        address address2 = 0xaee905fdd3ed851e48d22059575b9f4245a82b04;\n\n        uints1[address1] = 88;\n        uints1[address2] = 99;\n\n        DeviceData memory dev1 = DeviceData(&quot;deviceBrand&quot;, &quot;deviceYear&quot;, &quot;wearLevel&quot;);\n\n        structs1[address1] = dev1;\n\n        uintarray.push(8000);\n        uintarray.push(9000);\n\n        deviceDataArray.push(dev1);\n    }\n}\n</code></pre>\n</section>\n'},569:function(n,e,t){"use strict";t.r(e),e.default='<section><h3>crypto_roulette.sol</h3>\n<pre><code class="language-solidity">/*\n * @source: https://github.com/thec00n/smart-contract-honeypots/blob/master/CryptoRoulette.sol\n */\npragma solidity ^0.4.19;\n\n// CryptoRoulette\n//\n// Guess the number secretly stored in the blockchain and win the whole contract balance!\n// A new number is randomly chosen after each try.\n//\n// To play, call the play() method with the guessed number (1-20).  Bet price: 0.1 ether\n\ncontract CryptoRoulette {\n\n    uint256 private secretNumber;\n    uint256 public lastPlayed;\n    uint256 public betPrice = 0.1 ether;\n    address public ownerAddr;\n\n    struct Game {\n        address player;\n        uint256 number;\n    }\n    Game[] public gamesPlayed;\n\n    function CryptoRoulette() public {\n        ownerAddr = msg.sender;\n        shuffle();\n    }\n\n    function shuffle() internal {\n        // randomly set secretNumber with a value between 1 and 20\n        secretNumber = uint8(sha3(now, block.blockhash(block.number-1))) % 20 + 1;\n    }\n\n    function play(uint256 number) payable public {\n        require(msg.value &gt;= betPrice &amp;&amp; number &lt;= 10);\n\n        Game game;\n        game.player = msg.sender;\n        game.number = number;\n        gamesPlayed.push(game);\n\n        if (number == secretNumber) {\n            // win!\n            msg.sender.transfer(this.balance);\n        }\n\n        shuffle();\n        lastPlayed = now;\n    }\n\n    function kill() public {\n        if (msg.sender == ownerAddr &amp;&amp; now &gt; lastPlayed + 1 days) {\n            suicide(msg.sender);\n        }\n    }\n\n    function() public payable { }\n}\n</code></pre>\n<h3>crypto_roulette_fixed.sol</h3>\n<pre><code class="language-solidity">/*\n * @source: https://github.com/thec00n/smart-contract-honeypots/blob/master/CryptoRoulette.sol\n */\npragma solidity ^0.4.19;\n\n// CryptoRoulette\n//\n// Guess the number secretly stored in the blockchain and win the whole contract balance!\n// A new number is randomly chosen after each try.\n//\n// To play, call the play() method with the guessed number (1-20).  Bet price: 0.1 ether\n\ncontract CryptoRoulette {\n\n    uint256 private secretNumber;\n    uint256 public lastPlayed;\n    uint256 public betPrice = 0.1 ether;\n    address public ownerAddr;\n\n    struct Game {\n        address player;\n        uint256 number;\n    }\n    Game[] public gamesPlayed;\n\n    function CryptoRoulette() public {\n        ownerAddr = msg.sender;\n        shuffle();\n    }\n\n    function shuffle() internal {\n        // randomly set secretNumber with a value between 1 and 20\n        secretNumber = uint8(sha3(now, block.blockhash(block.number-1))) % 20 + 1;\n    }\n\n    function play(uint256 number) payable public {\n        require(msg.value &gt;= betPrice &amp;&amp; number &lt;= 10);\n\n        Game memory game;\n        game.player = msg.sender;\n        game.number = number;\n        gamesPlayed.push(game);\n\n        if (number == secretNumber) {\n            // win!\n            msg.sender.transfer(this.balance);\n        }\n\n        shuffle();\n        lastPlayed = now;\n    }\n\n    function kill() public {\n        if (msg.sender == ownerAddr &amp;&amp; now &gt; lastPlayed + 1 days) {\n            suicide(msg.sender);\n        }\n    }\n\n    function() public payable { }\n}\n\n</code></pre>\n</section>\n'},570:function(n,e,t){"use strict";t.r(e),e.default='<section><h3>transaction_malleablity.sol</h3>\n<pre><code class="language-solidity">pragma solidity ^0.4.24;\n\ncontract transaction_malleablity{\n  mapping(address =&gt; uint256) balances;\n  mapping(bytes32 =&gt; bool) signatureUsed;\n\n  constructor(address[] owners, uint[] init){\n    require(owners.length == init.length);\n    for(uint i=0; i &lt; owners.length; i ++){\n      balances[owners[i]] = init[i];\n    }\n  }\n\n  function transfer(\n        bytes _signature,\n        address _to,\n        uint256 _value,\n        uint256 _gasPrice,\n        uint256 _nonce)\n      public\n    returns (bool)\n    {\n      bytes32 txid = keccak256(abi.encodePacked(getTransferHash(_to, _value, _gasPrice, _nonce), _signature));\n      require(!signatureUsed[txid]);\n\n      address from = recoverTransferPreSigned(_signature, _to, _value, _gasPrice, _nonce);\n\n      require(balances[from] &gt; _value);\n      balances[from] -= _value;\n      balances[_to] += _value;\n\n      signatureUsed[txid] = true;\n    }\n\n    function recoverTransferPreSigned(\n        bytes _sig,\n        address _to,\n        uint256 _value,\n        uint256 _gasPrice,\n        uint256 _nonce)\n      public\n      view\n    returns (address recovered)\n    {\n        return ecrecoverFromSig(getSignHash(getTransferHash(_to, _value, _gasPrice, _nonce)), _sig);\n    }\n\n    function getTransferHash(\n        address _to,\n        uint256 _value,\n        uint256 _gasPrice,\n        uint256 _nonce)\n      public\n      view\n    returns (bytes32 txHash) {\n        return keccak256(address(this), bytes4(0x1296830d), _to, _value, _gasPrice, _nonce);\n    }\n\n    function getSignHash(bytes32 _hash)\n      public\n      pure\n    returns (bytes32 signHash)\n    {\n        return keccak256(&quot;\\x19Ethereum Signed Message:\\n32&quot;, _hash);\n    }\n\n    function ecrecoverFromSig(bytes32 hash, bytes sig)\n      public\n      pure\n    returns (address recoveredAddress)\n    {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        if (sig.length != 65) return address(0);\n        assembly {\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n        if (v &lt; 27) {\n          v += 27;\n        }\n        if (v != 27 &amp;&amp; v != 28) return address(0);\n        return ecrecover(hash, v, r, s);\n    }\n}\n\n</code></pre>\n<h3>transaction_malleablity_fixed.sol</h3>\n<pre><code class="language-solidity">pragma solidity ^0.4.24;\n\ncontract transaction_malleablity{\n  mapping(address =&gt; uint256) balances;\n  mapping(bytes32 =&gt; bool) signatureUsed;\n\n  constructor(address[] owners, uint[] init){\n    require(owners.length == init.length);\n    for(uint i=0; i &lt; owners.length; i ++){\n      balances[owners[i]] = init[i];\n    }\n  }\n\n  function transfer(\n        bytes _signature,\n        address _to,\n        uint256 _value,\n        uint256 _gasPrice,\n        uint256 _nonce)\n      public\n    returns (bool)\n    {\n      bytes32 txid = getTransferHash(_to, _value, _gasPrice, _nonce);\n      require(!signatureUsed[txid]);\n\n      address from = recoverTransferPreSigned(_signature, _to, _value, _gasPrice, _nonce);\n\n      require(balances[from] &gt; _value);\n      balances[from] -= _value;\n      balances[_to] += _value;\n\n      signatureUsed[txid] = true;\n    }\n\n    function recoverTransferPreSigned(\n        bytes _sig,\n        address _to,\n        uint256 _value,\n        uint256 _gasPrice,\n        uint256 _nonce)\n      public\n      view\n    returns (address recovered)\n    {\n        return ecrecoverFromSig(getSignHash(getTransferHash(_to, _value, _gasPrice, _nonce)), _sig);\n    }\n\n    function getTransferHash(\n        address _to,\n        uint256 _value,\n        uint256 _gasPrice,\n        uint256 _nonce)\n      public\n      view\n    returns (bytes32 txHash) {\n        return keccak256(address(this), bytes4(0x1296830d), _to, _value, _gasPrice, _nonce);\n    }\n\n    function getSignHash(bytes32 _hash)\n      public\n      pure\n    returns (bytes32 signHash)\n    {\n        return keccak256(&quot;\\x19Ethereum Signed Message:\\n32&quot;, _hash);\n    }\n\n    function ecrecoverFromSig(bytes32 hash, bytes sig)\n      public\n      pure\n    returns (address recoveredAddress)\n    {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        if (sig.length != 65) return address(0);\n        assembly {\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n        if (v &lt; 27) {\n          v += 27;\n        }\n        if (v != 27 &amp;&amp; v != 28) return address(0);\n        return ecrecover(hash, v, r, s);\n    }\n}\n\n</code></pre>\n</section>\n'},571:function(n,e,t){"use strict";t.r(e),e.default='<section><h3>incorrect_constructor_name1.sol</h3>\n<pre><code class="language-solidity">/*\n * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/wrong_constructor_name/incorrect_constructor.sol\n * @author: Ben Perez\n * Modified by Gerhard Wagner\n */\n\n\npragma solidity 0.4.24;\n\ncontract Missing{\n    address private owner;\n\n    modifier onlyowner {\n        require(msg.sender==owner);\n        _;\n    }\n    \n    function missing()\n        public \n    {\n        owner = msg.sender;\n    }\n\n    function () payable {} \n\n    function withdraw() \n        public \n        onlyowner\n    {\n       owner.transfer(this.balance);\n    }\n}\n\n</code></pre>\n<h3>incorrect_constructor_name1_fixed.sol</h3>\n<pre><code class="language-solidity">/*\n * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/wrong_constructor_name/incorrect_constructor.sol\n * @author: Ben Perez\n * Modified by Gerhard Wagner\n */\n\n\npragma solidity ^0.4.24;\n\ncontract Missing{\n    address private owner;\n\n    modifier onlyowner {\n        require(msg.sender==owner);\n        _;\n    }\n\n    constructor()\n        public\n    {\n        owner = msg.sender;\n    }\n\n    function () payable {}\n\n    function withdraw()\n        public\n        onlyowner\n    {\n       owner.transfer(this.balance);\n    }\n}\n\n</code></pre>\n<h3>incorrect_constructor_name2.sol</h3>\n<pre><code class="language-solidity">/*\n * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/wrong_constructor_name/incorrect_constructor.sol\n * @author: Ben Perez\n * Modified by Gerhard Wagner\n */\n\npragma solidity 0.4.24;\n\ncontract Missing{\n    address private owner;\n\n    modifier onlyowner {\n        require(msg.sender==owner);\n        _;\n    }\n\n    function Constructor()\n        public \n    {\n        owner = msg.sender;\n    }\n\n    function () payable {} \n\n    function withdraw() \n        public \n        onlyowner\n    {\n       owner.transfer(this.balance);\n    }\n\n}\n\n</code></pre>\n<h3>incorrect_constructor_name2_fixed.sol</h3>\n<pre><code class="language-solidity">/*\n * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/wrong_constructor_name/incorrect_constructor.sol\n * @author: Ben Perez\n * Modified by Gerhard Wagner\n */\n\npragma solidity ^0.4.24;\n\ncontract Missing{\n    address private owner;\n\n    modifier onlyowner {\n        require(msg.sender==owner);\n        _;\n    }\n\n    constructor()\n        public\n    {\n        owner = msg.sender;\n    }\n\n    function () payable {}\n\n    function withdraw()\n        public\n        onlyowner\n    {\n       owner.transfer(this.balance);\n    }\n\n}\n\n</code></pre>\n</section>\n'},572:function(n,e,t){"use strict";t.r(e),e.default="<section></section>\n"},573:function(n,e,t){"use strict";t.r(e),e.default="<section><h3>time_lock.sol</h3>\n<pre><code class=\"language-solidity\">/*\n * @author: Kaden Zipfel\n */\n\npragma solidity ^0.5.0;\n\ncontract TimeLock {\n    struct User {\n        uint amount; // amount locked (in eth)\n        uint unlockBlock; // minimum block to unlock eth\n    }\n\n    mapping(address =&gt; User) private users;\n\n    // Tokens should be locked for exact time specified\n    function lockEth(uint _time, uint _amount) public payable {\n        require(msg.value == _amount, 'must send exact amount');\n        users[msg.sender].unlockBlock = block.number + (_time / 14);\n        users[msg.sender].amount = _amount;\n    }\n\n    // Withdraw tokens if lock period is over\n    function withdraw() public {\n        require(users[msg.sender].amount &gt; 0, 'no amount locked');\n        require(block.number &gt;= users[msg.sender].unlockBlock, 'lock period not over');\n\n        uint amount = users[msg.sender].amount;\n        users[msg.sender].amount = 0;\n        (bool success, ) = msg.sender.call.value(amount)(&quot;&quot;);\n        require(success, 'transfer failed');\n    }\n}\n\n</code></pre>\n<h3>timed_crowdsale.sol</h3>\n<pre><code class=\"language-solidity\">pragma solidity ^0.5.0;\n\ncontract TimedCrowdsale {\n\n  event Finished();\n  event notFinished();\n\n  // Sale should finish exactly at January 1, 2019\n  function isSaleFinished() private returns (bool) {\n    return block.timestamp &gt;= 1546300800;\n  }\n\n  function run() public {\n  \tif (isSaleFinished()) {\n  \t\temit Finished();\n  \t} else {\n  \t\temit notFinished();\n  \t}\n  }\n\n}\n</code></pre>\n</section>\n"},574:function(n,e,t){"use strict";t.r(e),e.default='<section><h3>transaction_malleablity.sol</h3>\n<pre><code class="language-solidity">pragma solidity ^0.4.24;\n\ncontract transaction_malleablity{\n  mapping(address =&gt; uint256) balances;\n  mapping(bytes32 =&gt; bool) signatureUsed;\n\n  constructor(address[] owners, uint[] init){\n    require(owners.length == init.length);\n    for(uint i=0; i &lt; owners.length; i ++){\n      balances[owners[i]] = init[i];\n    }\n  }\n\n  function transfer(\n        bytes _signature,\n        address _to,\n        uint256 _value,\n        uint256 _gasPrice,\n        uint256 _nonce)\n      public\n    returns (bool)\n    {\n      bytes32 txid = keccak256(abi.encodePacked(getTransferHash(_to, _value, _gasPrice, _nonce), _signature));\n      require(!signatureUsed[txid]);\n\n      address from = recoverTransferPreSigned(_signature, _to, _value, _gasPrice, _nonce);\n\n      require(balances[from] &gt; _value);\n      balances[from] -= _value;\n      balances[_to] += _value;\n\n      signatureUsed[txid] = true;\n    }\n\n    function recoverTransferPreSigned(\n        bytes _sig,\n        address _to,\n        uint256 _value,\n        uint256 _gasPrice,\n        uint256 _nonce)\n      public\n      view\n    returns (address recovered)\n    {\n        return ecrecoverFromSig(getSignHash(getTransferHash(_to, _value, _gasPrice, _nonce)), _sig);\n    }\n\n    function getTransferHash(\n        address _to,\n        uint256 _value,\n        uint256 _gasPrice,\n        uint256 _nonce)\n      public\n      view\n    returns (bytes32 txHash) {\n        return keccak256(address(this), bytes4(0x1296830d), _to, _value, _gasPrice, _nonce);\n    }\n\n    function getSignHash(bytes32 _hash)\n      public\n      pure\n    returns (bytes32 signHash)\n    {\n        return keccak256(&quot;\\x19Ethereum Signed Message:\\n32&quot;, _hash);\n    }\n\n    function ecrecoverFromSig(bytes32 hash, bytes sig)\n      public\n      pure\n    returns (address recoveredAddress)\n    {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        if (sig.length != 65) return address(0);\n        assembly {\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n        if (v &lt; 27) {\n          v += 27;\n        }\n        if (v != 27 &amp;&amp; v != 28) return address(0);\n        return ecrecover(hash, v, r, s);\n    }\n}\n\n</code></pre>\n<h3>transaction_malleablity_fixed.sol</h3>\n<pre><code class="language-solidity">pragma solidity ^0.4.24;\n\ncontract transaction_malleablity{\n  mapping(address =&gt; uint256) balances;\n  mapping(bytes32 =&gt; bool) signatureUsed;\n\n  constructor(address[] owners, uint[] init){\n    require(owners.length == init.length);\n    for(uint i=0; i &lt; owners.length; i ++){\n      balances[owners[i]] = init[i];\n    }\n  }\n\n  function transfer(\n        bytes _signature,\n        address _to,\n        uint256 _value,\n        uint256 _gasPrice,\n        uint256 _nonce)\n      public\n    returns (bool)\n    {\n      bytes32 txid = getTransferHash(_to, _value, _gasPrice, _nonce);\n      require(!signatureUsed[txid]);\n\n      address from = recoverTransferPreSigned(_signature, _to, _value, _gasPrice, _nonce);\n\n      require(balances[from] &gt; _value);\n      balances[from] -= _value;\n      balances[_to] += _value;\n\n      signatureUsed[txid] = true;\n    }\n\n    function recoverTransferPreSigned(\n        bytes _sig,\n        address _to,\n        uint256 _value,\n        uint256 _gasPrice,\n        uint256 _nonce)\n      public\n      view\n    returns (address recovered)\n    {\n        return ecrecoverFromSig(getSignHash(getTransferHash(_to, _value, _gasPrice, _nonce)), _sig);\n    }\n\n    function getTransferHash(\n        address _to,\n        uint256 _value,\n        uint256 _gasPrice,\n        uint256 _nonce)\n      public\n      view\n    returns (bytes32 txHash) {\n        return keccak256(address(this), bytes4(0x1296830d), _to, _value, _gasPrice, _nonce);\n    }\n\n    function getSignHash(bytes32 _hash)\n      public\n      pure\n    returns (bytes32 signHash)\n    {\n        return keccak256(&quot;\\x19Ethereum Signed Message:\\n32&quot;, _hash);\n    }\n\n    function ecrecoverFromSig(bytes32 hash, bytes sig)\n      public\n      pure\n    returns (address recoveredAddress)\n    {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        if (sig.length != 65) return address(0);\n        assembly {\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n        if (v &lt; 27) {\n          v += 27;\n        }\n        if (v != 27 &amp;&amp; v != 28) return address(0);\n        return ecrecover(hash, v, r, s);\n    }\n}\n\n</code></pre>\n</section>\n'},575:function(n,e,t){"use strict";t.r(e),e.default='<section><h3>guess_the_random_number.sol</h3>\n<pre><code class="language-solidity">\n/*\n * @source: https://capturetheether.com/challenges/lotteries/guess-the-random-number/\n * @author: Steve Marx\n */\n\npragma solidity ^0.4.21;\n\ncontract GuessTheRandomNumberChallenge {\n    uint8 answer;\n\n    function GuessTheRandomNumberChallenge() public payable {\n        require(msg.value == 1 ether);\n        answer = uint8(keccak256(block.blockhash(block.number - 1), now));\n    }\n\n    function isComplete() public view returns (bool) {\n        return address(this).balance == 0;\n    }\n\n    function guess(uint8 n) public payable {\n        require(msg.value == 1 ether);\n\n        if (n == answer) {\n            msg.sender.transfer(2 ether);\n        }\n    }\n}\n\n</code></pre>\n<h3>guess_the_random_number_fixed.sol</h3>\n<pre><code class="language-solidity">/*\n * @source: https://capturetheether.com/challenges/lotteries/guess-the-random-number/\n * @author: Steve Marx\n */\n\npragma solidity ^0.4.25;\n\ncontract GuessTheRandomNumberChallenge {\n    uint8 answer;\n    uint8 commitedGuess;\n    uint commitBlock;\n    address guesser;\n\n    function GuessTheRandomNumberChallenge() public payable {\n        require(msg.value == 1 ether);\n    }\n\n    function isComplete() public view returns (bool) {\n        return address(this).balance == 0;\n    }\n\n    //Guess the modulo of the blockhash 20 blocks from your guess\n    function guess(uint8 _guess) public payable {\n        require(msg.value == 1 ether);\n        commitedGuess = _guess;\n        commitBlock = block.number;\n        guesser = msg.sender;\n    }\n    function recover() public {\n      //This must be called after the guessed block and before commitBlock+20\'s blockhash is unrecoverable\n      require(block.number &gt; commitBlock + 20 &amp;&amp; commitBlock+20 &gt; block.number - 256);\n      require(guesser == msg.sender);\n\n      if(uint(blockhash(commitBlock+20)) == commitedGuess){\n        msg.sender.transfer(2 ether);\n      }\n    }\n}\n</code></pre>\n<h3>old_blockhash.sol</h3>\n<pre><code class="language-solidity">pragma solidity ^0.4.24;\n\n//Based on the the Capture the Ether challange at https://capturetheether.com/challenges/lotteries/predict-the-block-hash/\n//Note that while it seems to have a 1/2^256 chance you guess the right hash, actually blockhash returns zero for blocks numbers that are more than 256 blocks ago so you can guess zero and wait.\ncontract PredictTheBlockHashChallenge {\n\n    struct guess{\n      uint block;\n      bytes32 guess;\n    }\n\n    mapping(address =&gt; guess) guesses;\n\n    constructor() public payable {\n        require(msg.value == 1 ether);\n    }\n\n    function lockInGuess(bytes32 hash) public payable {\n        require(guesses[msg.sender].block == 0);\n        require(msg.value == 1 ether);\n\n        guesses[msg.sender].guess = hash;\n        guesses[msg.sender].block  = block.number + 1;\n    }\n\n    function settle() public {\n        require(block.number &gt; guesses[msg.sender].block);\n\n        bytes32 answer = blockhash(guesses[msg.sender].block);\n\n        guesses[msg.sender].block = 0;\n        if (guesses[msg.sender].guess == answer) {\n            msg.sender.transfer(2 ether);\n        }\n    }\n}\n\n</code></pre>\n<h3>old_blockhash_fixed.sol</h3>\n<pre><code class="language-solidity">pragma solidity ^0.4.24;\n\n//Based on the the Capture the Ether challange at https://capturetheether.com/challenges/lotteries/predict-the-block-hash/\n//Note that while it seems to have a 1/2^256 chance you guess the right hash, actually blockhash returns zero for blocks numbers that are more than 256 blocks ago so you can guess zero and wait.\ncontract PredictTheBlockHashChallenge {\n\n    struct guess{\n      uint block;\n      bytes32 guess;\n    }\n\n    mapping(address =&gt; guess) guesses;\n\n    constructor() public payable {\n        require(msg.value == 1 ether);\n    }\n\n    function lockInGuess(bytes32 hash) public payable {\n        require(guesses[msg.sender].block == 0);\n        require(msg.value == 1 ether);\n\n        guesses[msg.sender].guess = hash;\n        guesses[msg.sender].block  = block.number + 1;\n    }\n\n    function settle() public {\n        require(block.number &gt; guesses[msg.sender].block +10);\n        //Note that this solution prevents the attack where blockhash(guesses[msg.sender].block) is zero\n        //Also we add ten block cooldown period so that a minner cannot use foreknowlege of next blockhashes\n        if(guesses[msg.sender].block - block.number &lt; 256){\n          bytes32 answer = blockhash(guesses[msg.sender].block);\n\n          guesses[msg.sender].block = 0;\n          if (guesses[msg.sender].guess == answer) {\n              msg.sender.transfer(2 ether);\n          }\n        }\n        else{\n          revert(&quot;Sorry your lottery ticket has expired&quot;);\n        }\n    }\n}\n\n</code></pre>\n<h3>random_number_generator.sol</h3>\n<pre><code class="language-solidity">pragma solidity ^0.4.25;\n\n// Based on TheRun contract deployed at 0xcac337492149bDB66b088bf5914beDfBf78cCC18.\ncontract RandomNumberGenerator {\n  uint256 private salt =  block.timestamp;\n\n  function random(uint max) view private returns (uint256 result) {\n    // Get the best seed for randomness\n    uint256 x = salt * 100 / max;\n    uint256 y = salt * block.number / (salt % 5);\n    uint256 seed = block.number / 3 + (salt % 300) + y;\n    uint256 h = uint256(blockhash(seed));\n    // Random number between 1 and max\n    return uint256((h / x)) % max + 1;\n  }\n}\n\n</code></pre>\n</section>\n'},576:function(n,e,t){"use strict";t.r(e),e.default="<section><h3>FunctionTypes.sol</h3>\n<pre><code class=\"language-solidity\">/*\n * @source: https://gist.github.com/wadeAlexC/7a18de852693b3f890560ab6a211a2b8\n * @author: Alexander Wade\n */\n\npragma solidity ^0.4.25;\n\ncontract FunctionTypes {\n    \n    constructor() public payable { require(msg.value != 0); }\n    \n    function withdraw() private {\n        require(msg.value == 0, 'dont send funds!');\n        address(msg.sender).transfer(address(this).balance);\n    }\n    \n    function frwd() internal\n        { withdraw(); }\n        \n    struct Func { function () internal f; }\n    \n    function breakIt() public payable {\n        require(msg.value != 0, 'send funds!');\n        Func memory func;\n        func.f = frwd;\n        assembly { mstore(func, add(mload(func), callvalue)) }\n        func.f();\n    }\n}\n\n</code></pre>\n</section>\n"},577:function(n,e,t){"use strict";t.r(e),e.default='<section><h3>access_control.sol</h3>\n<pre><code class="language-solidity">/*\n * @author: Steve Marx\n */\n\npragma solidity ^0.5.0;\n\nimport &quot;./ECDSA.sol&quot;;\n\ncontract AccessControl {\n    using ECDSA for bytes32;\n    mapping(address =&gt; bool) isAdmin;\n    mapping(address =&gt; bool) isRegularUser;\n    // Add admins and regular users.\n    function addUsers(\n        address[] calldata admins,\n        address[] calldata regularUsers,\n        bytes calldata signature\n    )\n        external\n    {\n        if (!isAdmin[msg.sender]) {\n            // Allow calls to be relayed with an admin\'s signature.\n            bytes32 hash = keccak256(abi.encodePacked(admins, regularUsers));\n            address signer = hash.toEthSignedMessageHash().recover(signature);\n            require(isAdmin[signer], &quot;Only admins can add users.&quot;);\n        }\n        for (uint256 i = 0; i &lt; admins.length; i++) {\n            isAdmin[admins[i]] = true;\n        }\n        for (uint256 i = 0; i &lt; regularUsers.length; i++) {\n            isRegularUser[regularUsers[i]] = true;\n        }\n    }\n}\n</code></pre>\n<h3>access_control_fixed_1.sol</h3>\n<pre><code class="language-solidity">/*\n * @author: Steve Marx\n * Modified by Kaden Zipfel\n */\n\npragma solidity ^0.5.0;\n\nimport &quot;./ECDSA.sol&quot;;\n\ncontract AccessControl {\n    using ECDSA for bytes32;\n    mapping(address =&gt; bool) isAdmin;\n    mapping(address =&gt; bool) isRegularUser;\n    // Add a single user, either an admin or regular user.\n    function addUser(\n        address user,\n        bool admin,\n        bytes calldata signature\n    )\n        external\n    {\n        if (!isAdmin[msg.sender]) {\n            // Allow calls to be relayed with an admin\'s signature.\n            bytes32 hash = keccak256(abi.encodePacked(user));\n            address signer = hash.toEthSignedMessageHash().recover(signature);\n            require(isAdmin[signer], &quot;Only admins can add users.&quot;);\n        }\n        if (admin) {\n            isAdmin[user] = true;\n        } else {\n            isRegularUser[user] = true;\n        }\n    }\n}\n</code></pre>\n<h3>access_control_fixed_2.sol</h3>\n<pre><code class="language-solidity">/*\n * @author: Steve Marx\n * Modified by Kaden Zipfel\n */\n\npragma solidity ^0.5.0;\n\nimport &quot;./ECDSA.sol&quot;;\n\ncontract AccessControl {\n    using ECDSA for bytes32;\n    mapping(address =&gt; bool) isAdmin;\n    mapping(address =&gt; bool) isRegularUser;\n    // Add admins and regular users.\n    function addUsers(\n        // Use fixed length arrays.\n        address[3] calldata admins,\n        address[3] calldata regularUsers,\n        bytes calldata signature\n    )\n        external\n    {\n        if (!isAdmin[msg.sender]) {\n            // Allow calls to be relayed with an admin\'s signature.\n            bytes32 hash = keccak256(abi.encodePacked(admins, regularUsers));\n            address signer = hash.toEthSignedMessageHash().recover(signature);\n            require(isAdmin[signer], &quot;Only admins can add users.&quot;);\n        }\n        for (uint256 i = 0; i &lt; admins.length; i++) {\n            isAdmin[admins[i]] = true;\n        }\n        for (uint256 i = 0; i &lt; regularUsers.length; i++) {\n            isRegularUser[regularUsers[i]] = true;\n        }\n    }\n}\n</code></pre>\n</section>\n'},578:function(n,e,t){"use strict";t.r(e),e.default="<section><h3>odd_even.sol</h3>\n<pre><code class=\"language-solidity\">/*\n * @source: https://gist.github.com/manojpramesh/336882804402bee8d6b99bea453caadd#file-odd-even-sol\n * @author: https://github.com/manojpramesh\n * Modified by Kaden Zipfel\n */\n\npragma solidity ^0.5.0;\n\ncontract OddEven {\n    struct Player {\n        address addr;\n        uint number;\n    }\n\n    Player[2] private players;\n    uint count = 0;\n\n    function play(uint number) public payable {\n            require(msg.value == 1 ether, 'msg.value must be 1 eth');\n            players[count] = Player(msg.sender, number);\n            count++;\n            if (count == 2) selectWinner();\n    }\n\n    function selectWinner() private {\n            uint n = players[0].number + players[1].number;\n            (bool success, ) = players[n%2].addr.call.value(address(this).balance)(&quot;&quot;);\n            require(success, 'transfer failed');\n            delete players;\n            count = 0;\n    }\n}\n</code></pre>\n<h4>Comments</h4>\n<p>The vulnerable version above requires the players to send the number they are using<br>\nas part of the transaction.<br>\nThis means the first player's number will be visible, allowing the second player to select a number<br>\nthat they know will make them a winner.<br>\n(This assumption is simplistic to illustrate - there are also possibilities to front-run players,<br>\namong other potential issues).</p>\n<p>In the fixed version below, the players instead submit a commitment that obfuscates their number,<br>\nand only subsequently reveal that they know the secret to set in train the process of a payout.</p>\n<h3>odd_even_fixed.sol</h3>\n<pre><code class=\"language-solidity\">/*\n * @source: https://github.com/yahgwai/rps\n * @author: Chris Buckland\n * Modified by Kaden Zipfel\n * Modified by Kacper uk\n */\n\npragma solidity ^0.5.0;\n\ncontract OddEven {\n    enum Stage {\n        FirstCommit,\n        SecondCommit,\n        FirstReveal,\n        SecondReveal,\n        Distribution\n    }\n\n    struct Player {\n        address addr;\n        bytes32 commitment;\n        bool revealed;\n        uint number;\n    }\n\n    Player[2] private players;\n    Stage public stage = Stage.FirstCommit;\n\n    function play(bytes32 commitment) public payable {\n        // Only run during commit stages\n        uint playerIndex;\n        if(stage == Stage.FirstCommit) playerIndex = 0;\n        else if(stage == Stage.SecondCommit) playerIndex = 1;\n        else revert(&quot;only two players allowed&quot;);\n\n        // Require proper amount deposited\n        // 1 ETH as a bet + 1 ETH as a bond\n        require(msg.value == 2 ether, 'msg.value must be 2 eth');\n\n        // Store the commitment\n        players[playerIndex] = Player(msg.sender, commitment, false, 0);\n\n        // Move to next stage\n        if(stage == Stage.FirstCommit) stage = Stage.SecondCommit;\n        else stage = Stage.FirstReveal;\n    }\n\n    function reveal(uint number, bytes32 blindingFactor) public {\n        // Only run during reveal stages\n        require(stage == Stage.FirstReveal || stage == Stage.SecondReveal, &quot;wrong stage&quot;);\n\n        // Find the player index\n        uint playerIndex;\n        if(players[0].addr == msg.sender) playerIndex = 0;\n        else if(players[1].addr == msg.sender) playerIndex = 1;\n        else revert(&quot;unknown player&quot;);\n\n        // Protect against double-reveal, which would trigger move to Stage.Distribution too early\n        require(!players[playerIndex].revealed, &quot;already revealed&quot;);\n\n        // Check the hash to prove the player's honesty\n        require(keccak256(abi.encodePacked(msg.sender, number, blindingFactor)) == players[playerIndex].commitment, &quot;invalid hash&quot;);\n\n        // Update player number if correct\n        players[playerIndex].number = number;\n\n        // Protect against double-reveal\n        players[playerIndex].revealed = true;\n\n        // Move to next stage\n        if(stage == Stage.FirstReveal) stage = Stage.SecondReveal;\n        else stage = Stage.Distribution;\n    }\n\n    function distribute() public {\n        // Only run during distribution stage\n        require(stage == Stage.Distribution, &quot;wrong stage&quot;);\n\n        // Find winner\n        uint n = players[0].number + players[1].number;\n\n        // Payout winners winnings and bond\n        players[n%2].addr.call.value(3 ether)(&quot;&quot;);\n\n        // Payback losers bond\n        players[(n+1)%2].addr.call.value(1 ether)(&quot;&quot;);\n\n        // Reset the state\n        delete players;\n        stage = Stage.FirstCommit;\n    }\n}\n\n</code></pre>\n</section>\n"},579:function(n,e,t){"use strict";t.r(e),e.default='<section><h3>guess_the_random_number.sol</h3>\n<pre><code class="language-solidity">\n/*\n * @source: https://capturetheether.com/challenges/lotteries/guess-the-random-number/\n * @author: Steve Marx\n */\n\npragma solidity ^0.4.21;\n\ncontract GuessTheRandomNumberChallenge {\n    uint8 answer;\n\n    function GuessTheRandomNumberChallenge() public payable {\n        require(msg.value == 1 ether);\n        answer = uint8(keccak256(block.blockhash(block.number - 1), now));\n    }\n\n    function isComplete() public view returns (bool) {\n        return address(this).balance == 0;\n    }\n\n    function guess(uint8 n) public payable {\n        require(msg.value == 1 ether);\n\n        if (n == answer) {\n            msg.sender.transfer(2 ether);\n        }\n    }\n}\n\n</code></pre>\n<h3>guess_the_random_number_fixed.sol</h3>\n<pre><code class="language-solidity">/*\n * @source: https://capturetheether.com/challenges/lotteries/guess-the-random-number/\n * @author: Steve Marx\n */\n\npragma solidity ^0.4.25;\n\ncontract GuessTheRandomNumberChallenge {\n    uint8 answer;\n    uint8 commitedGuess;\n    uint commitBlock;\n    address guesser;\n\n    function GuessTheRandomNumberChallenge() public payable {\n        require(msg.value == 1 ether);\n    }\n\n    function isComplete() public view returns (bool) {\n        return address(this).balance == 0;\n    }\n\n    //Guess the modulo of the blockhash 20 blocks from your guess\n    function guess(uint8 _guess) public payable {\n        require(msg.value == 1 ether);\n        commitedGuess = _guess;\n        commitBlock = block.number;\n        guesser = msg.sender;\n    }\n    function recover() public {\n      //This must be called after the guessed block and before commitBlock+20\'s blockhash is unrecoverable\n      require(block.number &gt; commitBlock + 20 &amp;&amp; commitBlock+20 &gt; block.number - 256);\n      require(guesser == msg.sender);\n\n      if(uint(blockhash(commitBlock+20)) == commitedGuess){\n        msg.sender.transfer(2 ether);\n      }\n    }\n}\n</code></pre>\n<h3>old_blockhash.sol</h3>\n<pre><code class="language-solidity">pragma solidity ^0.4.24;\n\n//Based on the the Capture the Ether challange at https://capturetheether.com/challenges/lotteries/predict-the-block-hash/\n//Note that while it seems to have a 1/2^256 chance you guess the right hash, actually blockhash returns zero for blocks numbers that are more than 256 blocks ago so you can guess zero and wait.\ncontract PredictTheBlockHashChallenge {\n\n    struct guess{\n      uint block;\n      bytes32 guess;\n    }\n\n    mapping(address =&gt; guess) guesses;\n\n    constructor() public payable {\n        require(msg.value == 1 ether);\n    }\n\n    function lockInGuess(bytes32 hash) public payable {\n        require(guesses[msg.sender].block == 0);\n        require(msg.value == 1 ether);\n\n        guesses[msg.sender].guess = hash;\n        guesses[msg.sender].block  = block.number + 1;\n    }\n\n    function settle() public {\n        require(block.number &gt; guesses[msg.sender].block);\n\n        bytes32 answer = blockhash(guesses[msg.sender].block);\n\n        guesses[msg.sender].block = 0;\n        if (guesses[msg.sender].guess == answer) {\n            msg.sender.transfer(2 ether);\n        }\n    }\n}\n\n</code></pre>\n<h3>old_blockhash_fixed.sol</h3>\n<pre><code class="language-solidity">pragma solidity ^0.4.24;\n\n//Based on the the Capture the Ether challange at https://capturetheether.com/challenges/lotteries/predict-the-block-hash/\n//Note that while it seems to have a 1/2^256 chance you guess the right hash, actually blockhash returns zero for blocks numbers that are more than 256 blocks ago so you can guess zero and wait.\ncontract PredictTheBlockHashChallenge {\n\n    struct guess{\n      uint block;\n      bytes32 guess;\n    }\n\n    mapping(address =&gt; guess) guesses;\n\n    constructor() public payable {\n        require(msg.value == 1 ether);\n    }\n\n    function lockInGuess(bytes32 hash) public payable {\n        require(guesses[msg.sender].block == 0);\n        require(msg.value == 1 ether);\n\n        guesses[msg.sender].guess = hash;\n        guesses[msg.sender].block  = block.number + 1;\n    }\n\n    function settle() public {\n        require(block.number &gt; guesses[msg.sender].block +10);\n        //Note that this solution prevents the attack where blockhash(guesses[msg.sender].block) is zero\n        //Also we add ten block cooldown period so that a minner cannot use foreknowlege of next blockhashes\n        if(guesses[msg.sender].block - block.number &lt; 256){\n          bytes32 answer = blockhash(guesses[msg.sender].block);\n\n          guesses[msg.sender].block = 0;\n          if (guesses[msg.sender].guess == answer) {\n              msg.sender.transfer(2 ether);\n          }\n        }\n        else{\n          revert(&quot;Sorry your lottery ticket has expired&quot;);\n        }\n    }\n}\n\n</code></pre>\n<h3>random_number_generator.sol</h3>\n<pre><code class="language-solidity">pragma solidity ^0.4.25;\n\n// Based on TheRun contract deployed at 0xcac337492149bDB66b088bf5914beDfBf78cCC18.\ncontract RandomNumberGenerator {\n  uint256 private salt =  block.timestamp;\n\n  function random(uint max) view private returns (uint256 result) {\n    // Get the best seed for randomness\n    uint256 x = salt * 100 / max;\n    uint256 y = salt * block.number / (salt % 5);\n    uint256 seed = block.number / 3 + (salt % 300) + y;\n    uint256 h = uint256(blockhash(seed));\n    // Random number between 1 and max\n    return uint256((h / x)) % max + 1;\n  }\n}\n\n</code></pre>\n</section>\n'},580:function(n,e,t){"use strict";t.r(e),e.default='<section><h3>dos_address.sol</h3>\n<pre><code class="language-solidity">pragma solidity ^0.4.25;\n\ncontract DosGas {\n\n    address[] creditorAddresses;\n    bool win = false;\n\n    function emptyCreditors() public {\n        if(creditorAddresses.length&gt;1500) {\n            creditorAddresses = new address[](0);\n            win = true;\n        }\n    }\n\n    function addCreditors() public returns (bool) {\n        for(uint i=0;i&lt;350;i++) {\n          creditorAddresses.push(msg.sender);\n        }\n        return true;\n    }\n\n    function iWin() public view returns (bool) {\n        return win;\n    }\n\n    function numberCreditors() public view returns (uint) {\n        return creditorAddresses.length;\n    }\n}\n\n</code></pre>\n<h3>dos_number.sol</h3>\n<pre><code class="language-solidity">pragma solidity ^0.4.25;\n\ncontract DosNumber {\n\n    uint numElements = 0;\n    uint[] array;\n\n    function insertNnumbers(uint value,uint numbers) public {\n\n        // Gas DOS if number &gt; 382 more or less, it depends on actual gas limit\n        for(uint i=0;i&lt;numbers;i++) {\n            if(numElements == array.length) {\n                array.length += 1;\n            }\n            array[numElements++] = value;\n        }\n    }\n\n    function clear() public {\n        require(numElements&gt;1500);\n        numElements = 0;\n    }\n\n    // Gas DOS clear\n    function clearDOS() public {\n\n        // number depends on actual gas limit\n        require(numElements&gt;1500);\n        array = new uint[](0);\n        numElements = 0;\n    }\n\n    function getLengthArray() public view returns(uint) {\n        return numElements;\n    }\n\n    function getRealLengthArray() public view returns(uint) {\n        return array.length;\n    }\n}\n\n</code></pre>\n<h3>dos_simple.sol</h3>\n<pre><code class="language-solidity">pragma solidity ^0.4.25;\n\ncontract DosOneFunc {\n\n    address[] listAddresses;\n\n    function ifillArray() public returns (bool){\n        if(listAddresses.length&lt;1500) {\n\n            for(uint i=0;i&lt;350;i++) {\n                listAddresses.push(msg.sender);\n            }\n            return true;\n\n        } else {\n            listAddresses = new address[](0);\n            return false;\n        }\n    }\n}\n\n</code></pre>\n</section>\n'},581:function(n,e,t){"use strict";t.r(e),e.default="<section><h2>Samples</h2>\n<h3>WalletLibrary.sol</h3>\n<pre><code class=\"language-solidity\">//sol Wallet\n// Multi-sig, daily-limited account proxy/wallet.\n// @authors:\n// Gav Wood &lt;g@ethdev.com&gt;\n// inheritable &quot;property&quot; contract that enables methods to be protected by requiring the acquiescence of either a\n// single, or, crucially, each of a number of, designated owners.\n// usage:\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\n// interior is executed.\n\npragma solidity ^0.4.9;\n\ncontract WalletEvents {\n  // EVENTS\n\n  // this contract only has six types of events: it can accept a confirmation, in which case\n  // we record owner and operation (hash) alongside it.\n  event Confirmation(address owner, bytes32 operation);\n  event Revoke(address owner, bytes32 operation);\n\n  // some others are in the case of an owner changing.\n  event OwnerChanged(address oldOwner, address newOwner);\n  event OwnerAdded(address newOwner);\n  event OwnerRemoved(address oldOwner);\n\n  // the last one is emitted if the required signatures change\n  event RequirementChanged(uint newRequirement);\n\n  // Funds has arrived into the wallet (record how much).\n  event Deposit(address _from, uint value);\n  // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\n  event SingleTransact(address owner, uint value, address to, bytes data, address created);\n  // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\n  event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data, address created);\n  // Confirmation still needed for a transaction.\n  event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\n}\n\ncontract WalletAbi {\n  // Revokes a prior confirmation of the given operation\n  function revoke(bytes32 _operation) external;\n\n  // Replaces an owner `_from` with another `_to`.\n  function changeOwner(address _from, address _to) external;\n\n  function addOwner(address _owner) external;\n\n  function removeOwner(address _owner) external;\n\n  function changeRequirement(uint _newRequired) external;\n\n  function isOwner(address _addr) constant returns (bool);\n\n  function hasConfirmed(bytes32 _operation, address _owner) external constant returns (bool);\n\n  // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\n  function setDailyLimit(uint _newLimit) external;\n\n  function execute(address _to, uint _value, bytes _data) external returns (bytes32 o_hash);\n  function confirm(bytes32 _h) returns (bool o_success);\n}\n\ncontract WalletLibrary is WalletEvents {\n  // TYPES\n\n  // struct for the status of a pending operation.\n  struct PendingState {\n    uint yetNeeded;\n    uint ownersDone;\n    uint index;\n  }\n\n  // Transaction structure to remember details of transaction lest it need be saved for a later call.\n  struct Transaction {\n    address to;\n    uint value;\n    bytes data;\n  }\n\n  // MODIFIERS\n\n  // simple single-sig function modifier.\n  modifier onlyowner {\n    if (isOwner(msg.sender))\n      _;\n  }\n  // multi-sig function modifier: the operation must have an intrinsic hash in order\n  // that later attempts can be realised as the same underlying operation and\n  // thus count as confirmations.\n  modifier onlymanyowners(bytes32 _operation) {\n    if (confirmAndCheck(_operation))\n      _;\n  }\n\n  // METHODS\n\n  // gets called when no other function matches\n  function() payable {\n    // just being sent some cash?\n    if (msg.value &gt; 0)\n      Deposit(msg.sender, msg.value);\n  }\n\n  // constructor is given number of sigs required to do protected &quot;onlymanyowners&quot; transactions\n  // as well as the selection of addresses capable of confirming them.\n  function initMultiowned(address[] _owners, uint _required) only_uninitialized {\n    m_numOwners = _owners.length + 1;\n    m_owners[1] = uint(msg.sender);\n    m_ownerIndex[uint(msg.sender)] = 1;\n    for (uint i = 0; i &lt; _owners.length; ++i)\n    {\n      m_owners[2 + i] = uint(_owners[i]);\n      m_ownerIndex[uint(_owners[i])] = 2 + i;\n    }\n    m_required = _required;\n  }\n\n  // Revokes a prior confirmation of the given operation\n  function revoke(bytes32 _operation) external {\n    uint ownerIndex = m_ownerIndex[uint(msg.sender)];\n    // make sure they're an owner\n    if (ownerIndex == 0) return;\n    uint ownerIndexBit = 2**ownerIndex;\n    var pending = m_pending[_operation];\n    if (pending.ownersDone &amp; ownerIndexBit &gt; 0) {\n      pending.yetNeeded++;\n      pending.ownersDone -= ownerIndexBit;\n      Revoke(msg.sender, _operation);\n    }\n  }\n\n  // Replaces an owner `_from` with another `_to`.\n  function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data)) external {\n    if (isOwner(_to)) return;\n    uint ownerIndex = m_ownerIndex[uint(_from)];\n    if (ownerIndex == 0) return;\n\n    clearPending();\n    m_owners[ownerIndex] = uint(_to);\n    m_ownerIndex[uint(_from)] = 0;\n    m_ownerIndex[uint(_to)] = ownerIndex;\n    OwnerChanged(_from, _to);\n  }\n\n  function addOwner(address _owner) onlymanyowners(sha3(msg.data)) external {\n    if (isOwner(_owner)) return;\n\n    clearPending();\n    if (m_numOwners &gt;= c_maxOwners)\n      reorganizeOwners();\n    if (m_numOwners &gt;= c_maxOwners)\n      return;\n    m_numOwners++;\n    m_owners[m_numOwners] = uint(_owner);\n    m_ownerIndex[uint(_owner)] = m_numOwners;\n    OwnerAdded(_owner);\n  }\n\n  function removeOwner(address _owner) onlymanyowners(sha3(msg.data)) external {\n    uint ownerIndex = m_ownerIndex[uint(_owner)];\n    if (ownerIndex == 0) return;\n    if (m_required &gt; m_numOwners - 1) return;\n\n    m_owners[ownerIndex] = 0;\n    m_ownerIndex[uint(_owner)] = 0;\n    clearPending();\n    reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\n    OwnerRemoved(_owner);\n  }\n\n  function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data)) external {\n    if (_newRequired &gt; m_numOwners) return;\n    m_required = _newRequired;\n    clearPending();\n    RequirementChanged(_newRequired);\n  }\n\n  // Gets an owner by 0-indexed position (using numOwners as the count)\n  function getOwner(uint ownerIndex) external constant returns (address) {\n    return address(m_owners[ownerIndex + 1]);\n  }\n\n  function isOwner(address _addr) constant returns (bool) {\n    return m_ownerIndex[uint(_addr)] &gt; 0;\n  }\n\n  function hasConfirmed(bytes32 _operation, address _owner) external constant returns (bool) {\n    var pending = m_pending[_operation];\n    uint ownerIndex = m_ownerIndex[uint(_owner)];\n\n    // make sure they're an owner\n    if (ownerIndex == 0) return false;\n\n    // determine the bit to set for this owner.\n    uint ownerIndexBit = 2**ownerIndex;\n    return !(pending.ownersDone &amp; ownerIndexBit == 0);\n  }\n\n  // constructor - stores initial daily limit and records the present day's index.\n  function initDaylimit(uint _limit) only_uninitialized {\n    m_dailyLimit = _limit;\n    m_lastDay = today();\n  }\n  // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\n  function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data)) external {\n    m_dailyLimit = _newLimit;\n  }\n  // resets the amount already spent today. needs many of the owners to confirm.\n  function resetSpentToday() onlymanyowners(sha3(msg.data)) external {\n    m_spentToday = 0;\n  }\n\n  // throw unless the contract is not yet initialized.\n  modifier only_uninitialized { if (m_numOwners &gt; 0) throw; _; }\n\n  // constructor - just pass on the owner array to the multiowned and\n  // the limit to daylimit\n  function initWallet(address[] _owners, uint _required, uint _daylimit) only_uninitialized {\n    initDaylimit(_daylimit);\n    initMultiowned(_owners, _required);\n  }\n\n  // kills the contract sending everything to `_to`.\n  function kill(address _to) onlymanyowners(sha3(msg.data)) external {\n    suicide(_to);\n  }\n\n  // Outside-visible transact entry point. Executes transaction immediately if below daily spend limit.\n  // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\n  // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\n  // and _data arguments). They still get the option of using them if they want, anyways.\n  function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 o_hash) {\n    // first, take the opportunity to check that we're under the daily limit.\n    if ((_data.length == 0 &amp;&amp; underLimit(_value)) || m_required == 1) {\n      // yes - just execute the call.\n      address created;\n      if (_to == 0) {\n        created = create(_value, _data);\n      } else {\n        if (!_to.call.value(_value)(_data))\n          throw;\n      }\n      SingleTransact(msg.sender, _value, _to, _data, created);\n    } else {\n      // determine our operation hash.\n      o_hash = sha3(msg.data, block.number);\n      // store if it's new\n      if (m_txs[o_hash].to == 0 &amp;&amp; m_txs[o_hash].value == 0 &amp;&amp; m_txs[o_hash].data.length == 0) {\n        m_txs[o_hash].to = _to;\n        m_txs[o_hash].value = _value;\n        m_txs[o_hash].data = _data;\n      }\n      if (!confirm(o_hash)) {\n        ConfirmationNeeded(o_hash, msg.sender, _value, _to, _data);\n      }\n    }\n  }\n\n  function create(uint _value, bytes _code) internal returns (address o_addr) {\n    /*\n    assembly {\n      o_addr := create(_value, add(_code, 0x20), mload(_code))\n      jumpi(invalidJumpLabel, iszero(extcodesize(o_addr)))\n    }\n    */\n  }\n\n  // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\n  // to determine the body of the transaction from the hash provided.\n  function confirm(bytes32 _h) onlymanyowners(_h) returns (bool o_success) {\n    if (m_txs[_h].to != 0 || m_txs[_h].value != 0 || m_txs[_h].data.length != 0) {\n      address created;\n      if (m_txs[_h].to == 0) {\n        created = create(m_txs[_h].value, m_txs[_h].data);\n      } else {\n        if (!m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data))\n          throw;\n      }\n\n      MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data, created);\n      delete m_txs[_h];\n      return true;\n    }\n  }\n\n  // INTERNAL METHODS\n\n  function confirmAndCheck(bytes32 _operation) internal returns (bool) {\n    // determine what index the present sender is:\n    uint ownerIndex = m_ownerIndex[uint(msg.sender)];\n    // make sure they're an owner\n    if (ownerIndex == 0) return;\n\n    var pending = m_pending[_operation];\n    // if we're not yet working on this operation, switch over and reset the confirmation status.\n    if (pending.yetNeeded == 0) {\n      // reset count of confirmations needed.\n      pending.yetNeeded = m_required;\n      // reset which owners have confirmed (none) - set our bitmap to 0.\n      pending.ownersDone = 0;\n      pending.index = m_pendingIndex.length++;\n      m_pendingIndex[pending.index] = _operation;\n    }\n    // determine the bit to set for this owner.\n    uint ownerIndexBit = 2**ownerIndex;\n    // make sure we (the message sender) haven't confirmed this operation previously.\n    if (pending.ownersDone &amp; ownerIndexBit == 0) {\n      Confirmation(msg.sender, _operation);\n      // ok - check if count is enough to go ahead.\n      if (pending.yetNeeded &lt;= 1) {\n        // enough confirmations: reset and run interior.\n        delete m_pendingIndex[m_pending[_operation].index];\n        delete m_pending[_operation];\n        return true;\n      }\n      else\n      {\n        // not enough: record that this owner in particular confirmed.\n        pending.yetNeeded--;\n        pending.ownersDone |= ownerIndexBit;\n      }\n    }\n  }\n\n  function reorganizeOwners() private {\n    uint free = 1;\n    while (free &lt; m_numOwners)\n    {\n      while (free &lt; m_numOwners &amp;&amp; m_owners[free] != 0) free++;\n      while (m_numOwners &gt; 1 &amp;&amp; m_owners[m_numOwners] == 0) m_numOwners--;\n      if (free &lt; m_numOwners &amp;&amp; m_owners[m_numOwners] != 0 &amp;&amp; m_owners[free] == 0)\n      {\n        m_owners[free] = m_owners[m_numOwners];\n        m_ownerIndex[m_owners[free]] = free;\n        m_owners[m_numOwners] = 0;\n      }\n    }\n  }\n\n  // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\n  // returns true. otherwise just returns false.\n  function underLimit(uint _value) internal onlyowner returns (bool) {\n    // reset the spend limit if we're on a different day to last time.\n    if (today() &gt; m_lastDay) {\n      m_spentToday = 0;\n      m_lastDay = today();\n    }\n    // check to see if there's enough left - if so, subtract and return true.\n    // overflow protection                    // dailyLimit check\n    if (m_spentToday + _value &gt;= m_spentToday &amp;&amp; m_spentToday + _value &lt;= m_dailyLimit) {\n      m_spentToday += _value;\n      return true;\n    }\n    return false;\n  }\n\n  // determines today's index.\n  function today() private constant returns (uint) { return now / 1 days; }\n\n  function clearPending() internal {\n    uint length = m_pendingIndex.length;\n\n    for (uint i = 0; i &lt; length; ++i) {\n      delete m_txs[m_pendingIndex[i]];\n\n      if (m_pendingIndex[i] != 0)\n        delete m_pending[m_pendingIndex[i]];\n    }\n\n    delete m_pendingIndex;\n  }\n\n  // FIELDS\n  address constant _walletLibrary = 0xcafecafecafecafecafecafecafecafecafecafe;\n\n  // the number of owners that must confirm the same operation before it is run.\n  uint public m_required;\n  // pointer used to find a free slot in m_owners\n  uint public m_numOwners;\n\n  uint public m_dailyLimit;\n  uint public m_spentToday;\n  uint public m_lastDay;\n\n  // list of owners\n  uint[256] m_owners;\n\n  uint constant c_maxOwners = 250;\n  // index on the list of owners to allow reverse lookup\n  mapping(uint =&gt; uint) m_ownerIndex;\n  // the ongoing operations.\n  mapping(bytes32 =&gt; PendingState) m_pending;\n  bytes32[] m_pendingIndex;\n\n  // pending transactions we have at present.\n  mapping (bytes32 =&gt; Transaction) m_txs;\n}\n\n</code></pre>\n<h3>simple_suicide.sol</h3>\n<pre><code class=\"language-solidity\">pragma solidity ^0.4.22;\n\ncontract SimpleSuicide {\n\n  function sudicideAnyone() {\n    selfdestruct(msg.sender);\n  }\n\n}\n\n</code></pre>\n<h3>suicide_multitx_feasible.sol</h3>\n<pre><code class=\"language-solidity\">pragma solidity ^0.4.23;\n\ncontract SuicideMultiTxFeasible {\n    uint256 private initialized = 0;\n    uint256 public count = 1;\n\n    function init() public {\n        initialized = 1;\n    }\n\n    function run(uint256 input) {\n        if (initialized == 0) {\n            return;\n        }\n\n        selfdestruct(msg.sender);\n    }\n}\n\n</code></pre>\n<h3>suicide_multitx_infeasible.sol</h3>\n<pre><code class=\"language-solidity\">pragma solidity ^0.4.23;\n\ncontract SuicideMultiTxFeasible {\n    uint256 private initialized = 0;\n    uint256 public count = 1;\n\n    function init() public {\n        initialized = 1;\n    }\n\n    function run(uint256 input) {\n        if (initialized != 2) {\n            return;\n        }\n\n        selfdestruct(msg.sender);\n    }\n}\n\n</code></pre>\n</section>\n"},582:function(n,e,t){"use strict";t(524)},583:function(n,e,t){var r=t(22)((function(i){return i[1]}));r.push([n.i,".sub-page-area[data-v-01649964]{display:flex;flex:1;flex-direction:column}p[data-v-01649964]{margin-bottom:0}",""]),r.locals={},n.exports=r},605:function(n,e,t){"use strict";t.r(e);var r=t(607),o=t(547),c=t(507),l=t(485),d=t(509),m=t(527),h=t(594),f=t(595),_=(t(11),t(67),t(36),t(292),t(14),t(5),t(37),t(491)),y={data:function(){return{item:{},subItem:{},example:{},samples:""}},computed:{breadcrumbs:function(){var n=this,e=[{text:"Home",disabled:!1,href:"/"},{text:"Techniques",disabled:!1,href:"/techniques"}],r=_.items.filter((function(e){return e.to==="/"+n.$route.params.tactic}));if(r&&r.length>0){this.item=r[0];var o=this.item.items.filter((function(e){return e.to==="/"+n.$route.params.technique}));if(o&&o.length>0){this.subItem=o[0];var c=this.subItem.examples.filter((function(e){return e.to==="/"+n.$route.params.example}));if(c&&c.length>0){this.example=c[0];try{this.samples=t(560)("./".concat(this.example.id,".md")).default}catch(n){}return[].concat(e,[{text:this.item.title,disabled:!1,href:"/tactics/".concat(this.$route.params.tactic)},{text:this.subItem.title,disabled:!1,href:"/techniques/".concat(this.$route.params.tactic,"/").concat(this.$route.params.technique)},{text:this.example.title,disabled:!0,href:"/techniques/".concat(this.$route.params.tactic,"/").concat(this.$route.params.technique,"/").concat(this.$route.params.example)}])}}}return e}}},w=(t(582),t(88)),component=Object(w.a)(y,(function(){var n=this,e=n._self._c;return e("div",{staticClass:"sub-page-area"},[e(r.a,{attrs:{items:n.breadcrumbs},scopedSlots:n._u([{key:"item",fn:function(t){var r=t.item;return[r&&r.text?e(o.a,{attrs:{href:r.href,disabled:r.disabled}},[n._v("\n                "+n._s(r.text.toUpperCase())+"\n            ")]):n._e()]}}])}),n._v(" "),e(m.a,[e(c.a,{staticClass:"elevation-0"},[e(l.b,[e("h2",[n._v(n._s(n.example.title))])]),n._v(" "),e(l.a,{staticClass:"text--primary"},[e(h.a,{attrs:{"no-gutters":""}},[e(d.a,{attrs:{cols:"10"}},[e("div",{staticClass:"description-area"},[n._v(n._s(n.example.description))])]),n._v(" "),e(d.a,{attrs:{cols:"2"}},[e(c.a,{staticClass:"elevation-0",staticStyle:{border:"1px solid #000"},attrs:{width:"100%",height:"100%"}},[e(l.a,{staticClass:"text--primary"},[e("p",[n._v("ID: "+n._s(n.example.id))]),n._v(" "),e("p",[n._v("Created: "+n._s(n.example.created))]),n._v(" "),e("p",[n._v("Last Modified: "+n._s(n.example.updated))])])],1)],1)],1)],1),n._v(" "),n.samples?e(l.a,{staticClass:"text--primary"},[e("div",{staticClass:"techniques-table-area"},[e("h2",{staticStyle:{"margin-bottom":"5px"}},[n._v("Samples")]),n._v(" "),e("div",{staticClass:"markdown-body",domProps:{innerHTML:n._s(n.samples)}})])]):n._e(),n._v(" "),n.example.reference&&n.example.reference.length>0?e(l.a,{staticClass:"text--primary"},[e("div",{staticClass:"techniques-table-area"},[e("h2",[n._v("Reference")]),n._v(" "),e(f.a,{scopedSlots:n._u([{key:"default",fn:function(){return[e("thead",[e("tr",[e("th",{staticClass:"text-left"},[n._v("\n                                        ID\n                                    ")]),n._v(" "),e("th",{staticClass:"text-left"},[n._v("\n                                        NAME\n                                    ")]),n._v(" "),e("th",{staticClass:"text-left"},[n._v("\n                                        Description\n                                    ")])])]),n._v(" "),e("tbody",n._l(n.example.reference,(function(t,r){return e("tr",{key:r,staticStyle:{cursor:"pointer"}},[e("td",[n._v(n._s(t.id))]),n._v(" "),e("td",[n._v(n._s(t.name))]),n._v(" "),e("td",[e("a",{attrs:{href:t.link,target:"_blank",rel:"noopener noreferrer"}},[n._v(n._s(t.link))])])])})),0)]},proxy:!0}],null,!1,4020769035)})],1)]):n._e()],1)],1)],1)}),[],!1,null,"01649964",null);e.default=component.exports}}]);